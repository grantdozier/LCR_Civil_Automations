"""
Module D - QA Report Generator
Generate professional Quality Assurance reports for plan review
"""
from typing import List, Dict, Optional
from pathlib import Path
from datetime import datetime
import logging

from docx import Document
from docx.shared import Inches, Pt, RGBColor
from docx.enum.text import WD_ALIGN_PARAGRAPH
from docx.oxml.ns import qn
from docx.oxml import OxmlElement

from services.module_d.compliance_checker import (
    ComplianceResult,
    Severity,
    ComplianceChecker,
)
from services.module_d.plan_extractor import SheetMetadata

logger = logging.getLogger(__name__)


class QAReportGenerator:
    """
    Generate professional QA reports for civil engineering plan review.

    Report includes:
    - Cover page with project information
    - Executive summary with pass/fail status
    - Detailed compliance results by category
    - Sheet-by-sheet review
    - Recommendations for corrections
    - Appendix with standard requirements reference
    """

    def __init__(self, output_dir: str = "/app/outputs"):
        """
        Initialize QA report generator.

        Args:
            output_dir: Directory for output files
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

    def generate_report(
        self,
        project_data: Dict,
        sheets: List[SheetMetadata],
        compliance_results: List[ComplianceResult],
        output_filename: Optional[str] = None
    ) -> str:
        """
        Generate complete QA report.

        Args:
            project_data: Project information (name, number, location, etc.)
            sheets: List of extracted sheet metadata
            compliance_results: List of compliance check results
            output_filename: Optional custom filename

        Returns:
            Path to generated report file
        """
        logger.info(f"Generating QA report for {project_data.get('project_name', 'project')}")

        # Create document
        doc = Document()

        # Set up document properties
        self._set_document_properties(doc, project_data)

        # Cover page
        self._add_cover_page(doc, project_data)
        doc.add_page_break()

        # Executive summary
        checker = ComplianceChecker()
        summary = checker.generate_summary(compliance_results)
        self._add_executive_summary(doc, summary, sheets)
        doc.add_page_break()

        # Detailed results by category
        self._add_results_by_category(doc, compliance_results)
        doc.add_page_break()

        # Sheet-by-sheet review
        self._add_sheet_review(doc, sheets, compliance_results)
        doc.add_page_break()

        # Recommendations
        self._add_recommendations(doc, compliance_results)
        doc.add_page_break()

        # Appendix - Standard requirements reference
        self._add_appendix(doc)

        # Save document
        if not output_filename:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            project_num = project_data.get('project_number', 'PROJ')
            output_filename = f"QA_Report_{project_num}_{timestamp}.docx"

        output_path = self.output_dir / output_filename
        doc.save(str(output_path))

        logger.info(f"Generated QA report: {output_path}")
        return str(output_path)

    def _set_document_properties(self, doc: Document, project_data: Dict):
        """Set document metadata properties"""
        core_properties = doc.core_properties
        core_properties.title = "Plan Review QA Report"
        core_properties.subject = project_data.get('project_name', '')
        core_properties.author = "LCR & Company - Automated QA System"
        core_properties.comments = "Generated by Module D - Plan Review & QA Automation"

    def _add_cover_page(self, doc: Document, project_data: Dict):
        """Add professional cover page"""
        # Title
        title = doc.add_paragraph()
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = title.add_run("PLAN REVIEW\n")
        run.font.size = Pt(28)
        run.font.bold = True
        run.font.color.rgb = RGBColor(0, 51, 102)  # Dark blue

        subtitle = doc.add_paragraph()
        subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = subtitle.add_run("QUALITY ASSURANCE REPORT\n\n\n")
        run.font.size = Pt(24)
        run.font.bold = True
        run.font.color.rgb = RGBColor(0, 51, 102)

        # Project information
        project_info = doc.add_paragraph()
        project_info.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = project_info.add_run(f"{project_data.get('project_name', 'Project Name')}\\n\\n")
        run.font.size = Pt(18)
        run.font.bold = True

        # Project details
        details = doc.add_paragraph()
        details.alignment = WD_ALIGN_PARAGRAPH.CENTER
        details_text = (
            f"Project Number: {project_data.get('project_number', 'N/A')}\\n"
            f"Location: {project_data.get('location', 'Lafayette, LA')}\\n"
            f"Client: {project_data.get('client_name', 'Client')}\\n\\n\\n"
        )
        run = details.add_run(details_text)
        run.font.size = Pt(14)

        # Footer
        doc.add_paragraph("\\n" * 10)  # Spacing

        footer = doc.add_paragraph()
        footer.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = footer.add_run("LCR & Company\\n")
        run.font.size = Pt(16)
        run.font.bold = True

        run = footer.add_run("Civil Engineering & Land Surveying\\n")
        run.font.size = Pt(12)

        date_para = doc.add_paragraph()
        date_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
        run = date_para.add_run(datetime.now().strftime("%B %d, %Y"))
        run.font.size = Pt(12)

    def _add_executive_summary(
        self,
        doc: Document,
        summary: Dict,
        sheets: List[SheetMetadata]
    ):
        """Add executive summary section"""
        doc.add_heading("EXECUTIVE SUMMARY", level=1)

        # Overall status
        status = summary['overall_status']
        status_para = doc.add_paragraph()
        status_para.add_run("Overall Status: ").font.bold = True
        status_run = status_para.add_run(status)
        status_run.font.bold = True
        status_run.font.size = Pt(14)

        if status == "PASS":
            status_run.font.color.rgb = RGBColor(0, 128, 0)  # Green
        else:
            status_run.font.color.rgb = RGBColor(204, 0, 0)  # Red

        doc.add_paragraph("")  # Spacing

        # Summary statistics
        stats_para = doc.add_paragraph()
        stats_para.add_run("Review Statistics:\\n\\n").font.bold = True

        stats_text = (
            f"Total Compliance Checks: {summary['total_checks']}\\n"
            f"Passed: {summary['passed']} ({summary['pass_rate']}%)\\n"
            f"Failed: {summary['failed']}\\n\\n"
            f"Critical Failures: {summary['critical_failures']}\\n"
            f"Warnings: {summary['warnings']}\\n"
            f"Informational: {summary['info']}\\n\\n"
            f"Sheets Reviewed: {len(sheets)}\\n"
        )
        stats_para.add_run(stats_text)

        # Sheet list
        doc.add_paragraph("")
        sheets_para = doc.add_paragraph()
        sheets_para.add_run("Sheets Included:\\n").font.bold = True
        for sheet in sheets:
            sheets_para.add_run(f"  • {sheet.sheet_number}: {sheet.sheet_title}\\n")

        # Category breakdown
        doc.add_paragraph("")
        cat_heading = doc.add_paragraph()
        cat_heading.add_run("Results by Category:\\n").font.bold = True

        # Create category table
        table = doc.add_table(rows=len(summary['by_category']) + 1, cols=4)
        table.style = 'Light Grid Accent 1'

        # Headers
        headers = ["Category", "Passed", "Failed", "Status"]
        for idx, header in enumerate(headers):
            cell = table.rows[0].cells[idx]
            cell.text = header
            cell.paragraphs[0].runs[0].font.bold = True
            cell.paragraphs[0].alignment = WD_ALIGN_PARAGRAPH.CENTER

        # Data rows
        for row_idx, (category, results) in enumerate(summary['by_category'].items(), start=1):
            row = table.rows[row_idx]
            row.cells[0].text = category
            row.cells[1].text = str(results['passed'])
            row.cells[2].text = str(results['failed'])

            status_cell = row.cells[3]
            if results['failed'] == 0:
                status_cell.text = "✓ PASS"
                status_cell.paragraphs[0].runs[0].font.color.rgb = RGBColor(0, 128, 0)
            else:
                status_cell.text = "✗ FAIL"
                status_cell.paragraphs[0].runs[0].font.color.rgb = RGBColor(204, 0, 0)

            # Center align
            for cell_idx in [1, 2, 3]:
                row.cells[cell_idx].paragraphs[0].alignment = WD_ALIGN_PARAGRAPH.CENTER

    def _add_results_by_category(self, doc: Document, results: List[ComplianceResult]):
        """Add detailed results organized by category"""
        doc.add_heading("DETAILED COMPLIANCE RESULTS", level=1)

        # Group results by category (extracted from rule_id)
        by_category = {}
        for result in results:
            category = result.rule_id.split("-")[0]
            if category not in by_category:
                by_category[category] = []
            by_category[category].append(result)

        # Add results for each category
        for category, cat_results in by_category.items():
            doc.add_heading(f"{category} Requirements", level=2)

            passed = sum(1 for r in cat_results if r.passed)
            failed = len(cat_results) - passed

            summary_para = doc.add_paragraph()
            summary_para.add_run(
                f"Status: {passed}/{len(cat_results)} passed ({failed} failed)\\n\\n"
            )

            # List each result
            for result in cat_results:
                result_para = doc.add_paragraph()

                # Status icon and rule ID
                if result.passed:
                    icon_run = result_para.add_run("✓ ")
                    icon_run.font.color.rgb = RGBColor(0, 128, 0)
                else:
                    icon_run = result_para.add_run("✗ ")
                    icon_run.font.color.rgb = RGBColor(204, 0, 0)

                result_para.add_run(f"[{result.rule_id}] ")

                # Message
                msg_run = result_para.add_run(result.message)
                if not result.passed:
                    msg_run.font.bold = True

                # Sheet number
                result_para.add_run(f" (Sheet {result.sheet_number})")

                # Add suggestions if failed
                if not result.passed and result.suggestions:
                    for suggestion in result.suggestions:
                        sugg_para = doc.add_paragraph(
                            f"    → {suggestion}",
                            style='List Bullet'
                        )

            doc.add_paragraph("")  # Spacing between categories

    def _add_sheet_review(
        self,
        doc: Document,
        sheets: List[SheetMetadata],
        results: List[ComplianceResult]
    ):
        """Add sheet-by-sheet review section"""
        doc.add_heading("SHEET-BY-SHEET REVIEW", level=1)

        for sheet in sheets:
            # Sheet header
            doc.add_heading(f"Sheet {sheet.sheet_number}: {sheet.sheet_title}", level=2)

            # Sheet metadata
            meta_para = doc.add_paragraph()
            meta_para.add_run("Sheet Information:\\n").font.bold = True
            meta_text = (
                f"Project: {sheet.project_name or 'N/A'}\\n"
                f"Project Number: {sheet.project_number or 'N/A'}\\n"
                f"Scale: {sheet.scale or 'N/A'}\\n"
                f"Extraction Confidence: {sheet.confidence_score * 100:.1f}%\\n\\n"
            )
            meta_para.add_run(meta_text)

            # Results for this sheet
            sheet_results = [r for r in results if r.sheet_number == sheet.sheet_number]

            if sheet_results:
                passed = sum(1 for r in sheet_results if r.passed)
                failed = len(sheet_results) - passed

                status_para = doc.add_paragraph()
                status_para.add_run(
                    f"Compliance Checks: {passed}/{len(sheet_results)} passed\\n\\n"
                )

                # List failed checks first (more important)
                failed_results = [r for r in sheet_results if not r.passed]
                if failed_results:
                    doc.add_paragraph("Issues Found:", style='Heading 3')
                    for result in failed_results:
                        issue_para = doc.add_paragraph(f"✗ {result.message}")
                        issue_para.runs[0].font.color.rgb = RGBColor(204, 0, 0)

                        if result.suggestions:
                            for suggestion in result.suggestions:
                                doc.add_paragraph(f"  → {suggestion}", style='List Bullet')

                # Then list passed checks
                passed_results = [r for r in sheet_results if r.passed]
                if passed_results:
                    doc.add_paragraph("Requirements Met:", style='Heading 3')
                    for result in passed_results:
                        pass_para = doc.add_paragraph(f"✓ {result.message}")
                        pass_para.runs[0].font.color.rgb = RGBColor(0, 128, 0)
            else:
                doc.add_paragraph("No compliance checks performed for this sheet.")

            doc.add_paragraph("")  # Spacing

    def _add_recommendations(self, doc: Document, results: List[ComplianceResult]):
        """Add recommendations section"""
        doc.add_heading("RECOMMENDATIONS", level=1)

        # Get all failed results
        failed = [r for r in results if not r.passed]

        if not failed:
            doc.add_paragraph(
                "All compliance checks passed. No corrections required."
            )
            return

        # Group by severity
        critical = [r for r in failed if r.severity == Severity.CRITICAL]
        warnings = [r for r in failed if r.severity == Severity.WARNING]
        info = [r for r in failed if r.severity == Severity.INFO]

        # Critical items
        if critical:
            doc.add_heading("CRITICAL - Must Fix Before Approval", level=2)
            doc.add_paragraph(
                f"The following {len(critical)} critical requirements must be addressed:"
            )

            for idx, result in enumerate(critical, start=1):
                item_para = doc.add_paragraph()
                item_para.add_run(f"{idx}. [{result.rule_id}] {result.message}\\n").font.bold = True
                item_para.add_run(f"   Sheet: {result.sheet_number}\\n")

                if result.suggestions:
                    item_para.add_run("   Recommendations:\\n")
                    for suggestion in result.suggestions:
                        item_para.add_run(f"     • {suggestion}\\n")

            doc.add_paragraph("")

        # Warnings
        if warnings:
            doc.add_heading("WARNINGS - Should Address", level=2)
            doc.add_paragraph(
                f"The following {len(warnings)} items should be addressed:"
            )

            for idx, result in enumerate(warnings, start=1):
                item_para = doc.add_paragraph(f"{idx}. [{result.rule_id}] {result.message}")
                item_para.add_run(f" (Sheet {result.sheet_number})")

            doc.add_paragraph("")

        # Info items
        if info:
            doc.add_heading("INFORMATIONAL - Consider Addressing", level=2)
            for idx, result in enumerate(info, start=1):
                doc.add_paragraph(f"{idx}. {result.message} (Sheet {result.sheet_number})")

    def _add_appendix(self, doc: Document):
        """Add appendix with standard requirements reference"""
        doc.add_heading("APPENDIX A: STANDARD REQUIREMENTS REFERENCE", level=1)

        doc.add_paragraph(
            "This section provides reference information for the standard requirements "
            "checked during plan review."
        )

        # LPDES
        doc.add_heading("Louisiana Pollutant Discharge Elimination System (LPDES)", level=2)
        lpdes_para = doc.add_paragraph()
        lpdes_para.add_run(
            "LPDES General Permit for Stormwater Discharges from Construction Activities "
            "is required for all projects disturbing one acre or more.\\n\\n"
            "Key Requirements:\\n"
            "• Stormwater Pollution Prevention Plan (SWPPP)\\n"
            "• Weekly inspections during active construction\\n"
            "• BMP installation before land disturbance\\n"
            "• Reporting of discharge violations\\n"
        )

        # LUS
        doc.add_heading("Lafayette Utilities System (LUS)", level=2)
        lus_para = doc.add_paragraph()
        lus_para.add_run(
            "LUS coordination is required for all projects affecting utilities.\\n\\n"
            "Key Requirements:\\n"
            "• Coordinate utility locations before excavation\\n"
            "• Call Louisiana One Call (811) 48 hours before digging\\n"
            "• Obtain utility permits for new connections\\n"
        )

        # DOTD
        doc.add_heading("Louisiana Department of Transportation (DOTD)", level=2)
        dotd_para = doc.add_paragraph()
        dotd_para.add_run(
            "DOTD Standard Specifications apply to roadway and drainage work.\\n\\n"
            "Common Standards:\\n"
            "• Pavement sections and materials\\n"
            "• Drainage pipe specifications\\n"
            "• Traffic control requirements\\n"
        )

        # ASTM
        doc.add_heading("American Society for Testing and Materials (ASTM)", level=2)
        astm_para = doc.add_paragraph()
        astm_para.add_run(
            "ASTM standards for materials testing and specifications.\\n\\n"
            "Commonly Referenced:\\n"
            "• ASTM D1557: Soil compaction testing\\n"
            "• ASTM C478: Precast reinforced concrete manholes\\n"
            "• ASTM C76: Reinforced concrete pipe\\n"
        )

        # Lafayette UDC
        doc.add_heading("Lafayette Unified Development Code (UDC)", level=2)
        udc_para = doc.add_paragraph()
        udc_para.add_run(
            "UDC Section 3.2 governs drainage requirements in Lafayette Parish.\\n\\n"
            "Key Requirements:\\n"
            "• Post-development runoff ≤ pre-development\\n"
            "• Minimum pipe sizes and slopes\\n"
            "• Detention/retention requirements\\n"
            "• Maintenance access provisions\\n"
        )

    def generate_summary_pdf(
        self,
        project_data: Dict,
        summary: Dict,
        output_filename: Optional[str] = None
    ) -> str:
        """
        Generate single-page PDF summary (quick view).

        Args:
            project_data: Project information
            summary: Summary statistics from compliance checker
            output_filename: Optional custom filename

        Returns:
            Path to generated summary PDF
        """
        # This would use reportlab or similar for PDF generation
        # For now, just log that it's not implemented
        logger.info("PDF summary generation not yet implemented - use Word format")
        raise NotImplementedError("PDF generation requires reportlab library")
